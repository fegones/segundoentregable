# Pseudocódigo del Analizador de Ventas (nivel básico)

Este archivo recoge el pseudocódigo y los pasos principales que aparecen en `Programa.py`, `Prueba.py` y `Nuevo.py`. Está pensado para ser una guía directa para implementar las funciones usando solo Python estándar.

## Objetivo
- Preparar, unir y agregar datos de ventas para responder preguntas sobre ventas por producto, impacto de medios de pago y preferencia de pago del Top 10 de clientes.

## Archivos de datos esperados
- `ventas.csv` — Encabezado de cada venta (id_venta, fecha, cliente, medio_pago, etc.)
- `detalle_ventas.csv` — Detalle por línea (id_venta, id_producto, nombre_producto, cantidad, importe)
- `productos.csv` — Catálogo de productos (id_producto, categoria, precio_unitario)
- `clientes.csv` — Información de clientes (id_cliente, nombre, segmento)

## Pasos generales (alto nivel)
1. CARGA: leer los CSV y convertirlos en listas de diccionarios
   - leer_csv_simple(path) -> lista de dicts
2. VALIDAR: asegurar que las columnas esperadas están presentes
   - validar_columnas(rows, expected_cols) -> True/False
3. UNIR: unir `ventas` con `detalle_ventas` por `id_venta` -> `df_sales`
   - unir_por_id(ventas, detalle, 'id_venta') -> lista de dicts combinada
4. PROCESAR FECHAS: extraer `año` y `mes` de la columna `fecha`
   - extraer_anio_mes(rows, 'fecha') -> agrega claves 'anio', 'mes'
5. AGREGACIONES:
   - ventas_por_producto_y_tiempo = agrupar_sumar(df_sales, ['anio','mes','nombre_producto'], 'importe')
   - ventas_por_medio_pago = agrupar_sumar(df_sales, ['medio_pago'], 'importe')
   - gasto_por_cliente = agrupar_sumar(df_sales, ['cliente'], 'importe')
6. TOP N:
   - top_10_clientes = tomar_top_n(gasto_por_cliente, 10)
7. ANALISIS MVC (Top 10):
   - filtrar df_sales por clientes en top_10_clientes
   - agrupar por 'medio_pago' y sumar 'importe'
8. RESULTADOS:
   - calcular porcentajes (por ejemplo, por medio de pago)
   - escribir reportes CSV de salida (opcional)

## Pseudocódigo (detallado)

```pseudocode
FUNC leer_csv_simple(path):
    abrir archivo path en modo lectura
    leer todas las líneas no vacías
    header = split primera línea por ','
    rows = []
    para cada línea en líneas[1:]:
        valores = split linea por ','
        fila = mapear header a valores -> dict
        append fila a rows
    return rows

FUNC validar_columnas(rows, expected):
    si rows está vacío: return False
    return expected subset de keys de rows[0]

FUNC unir_por_id(left_rows, right_rows, clave='id_venta'):
    crear índice derecho: dict donde clave -> lista de filas del right
    resultado = []
    para each fila_left in left_rows:
        key = fila_left[clave]
        si key en índice derecho:
            para each fila_right en índice derecho[key]:
                merged = copiar fila_left y actualizar con fila_right
                append merged a resultado
        else:
            append copia de fila_left a resultado
    return resultado

FUNC extraer_anio_mes(rows, fecha_col='fecha'):
    para r in rows:
        if fecha_col en r y r[fecha_col] no vacío:
            parsear fecha (ej: 'YYYY-MM-DD')
            r['anio'] = año
            r['mes'] = mes
    return rows

FUNC agrupar_sumar(rows, group_keys, sum_col):
    totals = {}  # key tuple -> suma
    for r in rows:
        key = tuple(r.get(k, '') for k in group_keys)
        value = int(r.get(sum_col, '0'))
        totals[key] = totals.get(key, 0) + value
    return totals  # o convertir a lista de dicts si se prefiere

FUNC tomar_top_n(agg_dict, n):
    ordenar agg_dict.items por valor desc
    devolver las n keys principales

FUNC calcular_porcentajes(agg_dict):
    total = sum de todos los valores
    para k,v en agg_dict.items:
        pct = v / total * 100
        guardar pct en estructura de salida
    return estructura con valores y porcentajes

FUNC escribir_csv(path, rows, header):
    abrir archivo path en modo escritura
    escribir header
    para r en rows:
        escribir linea con valores en orden de header

FIN
```

## Notas prácticas
- Mantener separación entre funciones de I/O (lectura/escritura) y funciones de procesamiento.
- Usar `encoding='utf-8'` al abrir archivos.
- Manejar conversiones numéricas con int(...) o float(...), con fallback a 0 si el valor no es válido.

---

Si quieres, puedo:
- Crear un archivo `procesamiento.py` que implemente estas funciones en Python puro y agregar ejemplos de uso.
- Generar tests simples que validen el comportamiento con datos de ejemplo en memoria.

Dime cuál prefieres y lo implemento ahora.